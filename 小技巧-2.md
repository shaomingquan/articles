***pipe to dom***

利用`document.write`可以逐次写入内容的特性，在加上最近支持的`WritableStream`，通过一个临时的iframe做代理，将在iframe中生成的dom节点移交到页面里。[https://streams.spec.whatwg.org/demos/streaming-element.html](https://streams.spec.whatwg.org/demos/streaming-element.html)。

pipe的方法可将大内容分割为chunks，在官方的例子中通过打断点可知到返回的内容被分割成了两份。第一份16384字节。

技巧虽炫酷，但前端接受大文本文件过来的场景，至今没遇到过。

```js
this.writable = new WritableStream({
  async write(chunk) {
    const iframe = await iframeReady; // 两次
    iframe.contentDocument.write(chunk);
  },
  close: end,
  abort: end
});
```

***一段阻塞渲染的启示***

首先下面代码很形象的演示了脚本阻塞。打开命令行工具，刷新页面，在debugger位置暂停。可以发现2和3没有渲染，说明如果中间加了执行时间较长的脚本，体验下降是没跑了。

还有关于在阻塞时3是否渲染的问题：浏览器在渲染之前，内存中预先解析出的dom树，浏览器使用这个树形数据结构进行先序渲染，所以3不渲染（深度优先则3会渲染）。

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>test iframe</title>
  </head>
  <body>
    <div>
      <div>1</div>
      <script>debugger;</script>
      <div>2</div>
    </div>
    <span>3</span>
  </body>
</html>
```

***assign 的小坑***

```js
> Object.assign({}, 'xxx')
{ '0': 'x', '1': 'x', '2': 'x' }
```

assign会把字符串转成一个没啥意义的对象，很不严谨。此处抛异常较好。

***长连接要标准化了？***

同事分享了最新的服务器推标准。不过看起来更像是一个标准化的长连接。

[https://github.com/song940/server-send-events/](https://github.com/song940/server-send-events/)

[https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events](https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events)

***程序执行命令行列表过长小技巧***

使用`bash -c`，相当于在bash中再调用bash，可以把整个命令写成一个字符串，像这样`bash -c "ls -l"`，在node或者golang的命令行调用功能中，经常需要通过空格把所有参数分隔开，使用`base -c`，把需要执行的命令当成最后一个参数即可。

```go
lsCmd := exec.Command("bash", "-c", "ls -a -l -h")
```