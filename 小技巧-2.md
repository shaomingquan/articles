***pipe to dom***

利用`document.write`可以逐次写入内容的特性，在加上最近支持的`WritableStream`，通过一个临时的iframe做代理，将在iframe中生成的dom节点移交到页面里。[https://streams.spec.whatwg.org/demos/streaming-element.html](https://streams.spec.whatwg.org/demos/streaming-element.html)。

pipe的方法可将大内容分割为chunks，在官方的例子中通过打断点可知到返回的内容被分割成了两份。第一份16384字节。

技巧虽炫酷，但前端接受大文本文件过来的场景，至今没遇到过。

```js
this.writable = new WritableStream({
  async write(chunk) {
    const iframe = await iframeReady; // 两次
    iframe.contentDocument.write(chunk);
  },
  close: end,
  abort: end
});
```

***一段阻塞渲染的启示***

首先下面代码很形象的演示了脚本阻塞。打开命令行工具，刷新页面，在debugger位置暂停。可以发现2和3没有渲染，说明如果中间加了执行时间较长的脚本，体验下降是没跑了。

还有关于在阻塞时3是否渲染的问题：浏览器在渲染之前，内存中预先解析出的dom树，浏览器使用这个树形数据结构进行先序渲染，所以3不渲染（深度优先则3会渲染）。

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>test iframe</title>
  </head>
  <body>
    <div>
      <div>1</div>
      <script>debugger;</script>
      <div>2</div>
    </div>
    <span>3</span>
  </body>
</html>
```