#### 概述

后端与前端很不同的一点是，后端的基础知识是相通的。做后端相关工作时，工程师更多的是掌握操作系统以及很多譬如消息队列数据库之类的工具，而语言更多时候只是一个工具，去打通工程师与操作系统，打通工程师与各种工具的服务端。语言作为工具，每一种语言有自己适合的领域，我发现很多专职的后端工程师掌握不止一门语言，在不同的场景下，他们会选择不同的语言。

所谓泛后端知识，是那些可以脱离语言范畴讨论的通用的点，用什么工具解决什么问题，如何选择语言等等。

作为对比，前端的各个端分别基于不同的体系，背后有不同的巨头支撑着。我们很难将所有的经验从一个端带到另一个端，让web前端和java后端同时学习android开发，谁做得好我觉得说不好，即使都是前端，web前端的经验能带过去的不多。硬要说泛前端知识，我暂且可以列出下面几点：

- 图形与动画。
- 交互设计。
- ui设计。
- 组件化，函数式，事件驱动等开发思想。

我是一个前端，从大二开始就接触前端外包项目，后来nodejs出现了，我发现了全栈这个词，学生时期的后端编程很玩具，甚至很多同学在学完后端和前端之后都觉得自己是个全占了，到了公司面对各种后端工具以及两眼一抹黑的操作系统，才感觉到什么是“伪全栈”。

随着工作时间越来越长，我越来越意识到前端的一些问题，做前端的难处：

- 复杂的工具链：这个主要web前端的难处，web前端的开发环境是最好搭的也是最难搭的，现在的前端如果连前端自动化都不会玩恐怕有些out，因为缺乏官方的支持，web前端的开发过程有着各种各样的玩法，几乎在所有大公司中，都会有专人去搞工程化建设，每种工程化大同小异。而工程化的过程涉及到组件化工具的选择，开发框架选择，目录规范制定，**依赖程度过重使人毫无安全感**，开发环境住够轻，才是下班的保障。
- 各用户代理明争暗斗，战争不断：兼容性是个很烦的东西，在企业中，前端又不得不去做这些事情，处理兼容性问题营养价值为零，最后学到的只有no hack, no pain。
- 客户端方案的高淘汰率：flash，winphone等等，谁是下一个，真的不好说。
- 小鬼缠身：做前端很辛苦，ui交互后端产品每天围着你转。
- 高速更新的工具链、语言、标准和用户代理：比如面向v8引擎的javascript语法优化，如果打算使用优化，那么不好意思，请跟进google爸爸对v8的更新，以防在以后打脸。没有拥抱变化的觉悟就不要深究前端。我看倒不如看看泛前端的东西。

做后端的难处也很明显：

- 与前端不同，后端的工作开发只是工作的一小部分，自动化测试又占一部分，运维占了其中一大部分。
- 产品周期长，事故多是大事故。前端的产品周期一般来说都比较短。

说到底，前端的工作经验不能帮助你在未来早点下班，用户代理的迭代，淘汰，工具链的更新，打磨着现代前端的热情，以及精益求精的态度。

今天的主题是泛后端，说道泛后端，我今天想说以下几个主题：

- 当我们在写后端的时候，操作系统在干嘛。
	- 系统调用。（用户态，内核态，当我们在用不同的工具做服务器开发的时候，他们的内核态的运作模式有着共性，切换上下文，较昂贵，应减少不必要的系统调用，io模型与系统调用，我们知道，nodejs是非阻塞式io，其底层原理，是使用了epoll，kqueue？了解各种并发模型，C10K问题）
    - 硬件的价值，服务特点与硬件的分配。
- 保证你的服务稳定。
    - 系统指标监控与复盘。（机器实时指标与系统长期指标）。
    - 系统健康状态。
    - 指标置换。
    - svc，cgroup（保护你的系统）。
    - 学会拒绝（配额，以及拒绝服务，业务方压测的教训）。
    - 击穿，雪崩，容灾（成也缓存，败也缓存。）
- 冗余的力量。
    - 多实例水平拓展。
    - 备份。
    - 缓存降低计算压力。
    - 池（连接池，代理池）
- 用户代理缓存（免费的资源）。
- 我们需要怎样的分布式？
    - 为什么使用分布式应用。（业务变大，大型机太贵）
    - 平行（不平行）服务端（客户端）。（我们更多的关注客户端，大公司往往会有一大波人专门，使用他们的服务也好也不好，从效果和运维成本两个维度考虑，能力也大责任越大，当专业人员面对更复杂的任务，效果无法与非专业人员面对简单任务时合理对比，当然，运维成本肯定会降低。如果使用别人的服务，了解正在使用的分布式应用）。
- 了解你的工具
    - 垃圾回收机制与系统指标的关系。
    - 线程协程进程，场景与复杂度，在团队中的可维护程度。
    - 通信协议也是工具。（rpc协议，端到服务协议）（文本协议与二进制协议，文本与二进制实际上都是在网络中传输，文本的区别在于解码方式简单粗暴，不利于流的大小控制？）。
- 写靠谱的代码
    - 线程安全。（未加锁而被坑的案例，分布式锁）。
    - 读cache，写buffer，分布式hashing（使用lru缓存，监控好buffer，hashing要避免热点（热点也是一用典型的不健康曲线））。
    - 优化传输格式
    - 削峰，代码削峰（加随机数，让时间离散），缓存预热，队列削峰。
    - 副作用代码未尝不可。
- 学习一个数据库的通用套路。
    - 当我们在使用索引的时候（专业人士讨论，kylin时的超大冗余索引，es添加模糊索引的时候，会有多大的磁盘以及效率损耗）。
    - 主备分离，读写分离，数据模型。
- 密码知识
    - 摘要算法（你的摘要是否安全）。
    - 对称加密，非对称加密。
    - 压缩。
- 通过了解各个云平台产品的功能，了解通用（先进）技术。
- tips
    - 不可抗力（磁盘文件损坏，遇到两次，java二进制文件，npm某包的某文件）
    - 版本依赖的坑（scons，py，bloomd发布的坑）
    - 等幂操作。
    - 长轮询。轮询。给后端提task。socket。
    - 硬编码，线上配置，权衡，兜底配置。
    - 学会找瓶颈。
    
    
#### c10k

单进程文件描述符的数量
