> 所谓泛后端知识，是那些可以脱离语言范畴讨论的通用的点，用什么工具解决什么问题，如何选择语言等等，而不是具体语言在具体场景的具体用法。

### 概述

后端与前端很不同的一点是，后端的基础知识是相通的。做后端相关工作时，工程师更多的是掌握操作系统以及很多譬如消息队列数据库之类的工具，而语言更多时候只是一个工具，去打通工程师与操作系统，打通工程师与各种工具的服务端。语言作为工具，每一种语言有自己适合的领域，我发现很多专职的后端工程师掌握不止一门语言，在不同的场景下，他们会选择不同的语言。后端的平台即操作系统，**后端与平台是强耦合的**。

作为对比，前端的各个端分别基于不同的体系，背后有不同的巨头支撑着。我们很难将所有的经验从一个端带到另一个端，让web前端和java后端同时学习android开发，谁做得好我觉得说不好，即使都是前端，web前端的经验能带过去的不多。前端在每个端面对的平台都不一样，**前端与平台是弱耦合的**。硬要说泛前端知识，我暂且可以列出下面几点：

- 图形与动画。
- 交互设计。
- ui设计。
- 组件化，函数式，事件驱动等开发思想。

随着工作时间越来越长，我越来越意识到前端的一些问题，做前端的难处：

- 复杂的工具链：这个主要web前端的难处，web前端的开发环境是最好搭的也是最难搭的，现在的前端如果连前端自动化都不会玩恐怕有些out，因为缺乏官方的支持，web前端的开发过程有着各种各样的玩法，几乎在所有大公司中，都会有专人去搞工程化建设，每种工程化大同小异。而工程化的过程涉及到组件化工具的选择，开发框架选择，目录规范制定，**依赖程度过重使人毫无安全感**，开发环境住够轻，才是下班的保障。
- 各用户代理明争暗斗，战争不断：兼容性是个很烦的东西，在企业中，前端又不得不去做这些事情，处理兼容性问题营养价值为零，最后学到的只有no hack, no pain。
- 客户端方案的高淘汰率：flash，winphone等等，谁是下一个，真的不好说。
- 小鬼缠身：做前端很辛苦，ui交互后端产品每天围着你转。
- 高速更新的工具链、语言、标准和用户代理：比如面向v8引擎的javascript语法优化，如果打算使用优化，那么不好意思，请跟进google爸爸对v8的更新，以防在以后打脸。没有拥抱变化的觉悟就不要深究前端。我看倒不如看看泛前端的东西。

做后端的难处也很明显：

- 与前端不同，后端的工作开发只是工作的一小部分，自动化测试又占一部分，运维占了其中一大部分。
- 产品周期长，事故多是大事故。前端的产品周期一般来说都比较短，或者后期维护成本不高。

说到底，前端的工作经验不能帮助你在未来早点下班，**用户代理的迭代，淘汰，工具链的更新，打磨着现代前端的热情，以及精益求精的态度**。

我是一个前端，从大二开始就接触前端外包项目，后来nodejs出现了，我发现了全栈这个词，学生时期的后端编程很玩具，甚至很多同学在学完后端和前端之后都觉得自己是个全栈了，到了公司面对各种后端工具以及两眼一抹黑的操作系统，才感觉到什么是“伪全栈”。所以能写出后端应用其实不重要，三五天其实就够了，重要的是后端背后庞大的知识体系，也就是脱离语言泛后端知识。

### 泛后端知识体系

可以有以下几个大分类：**操作系统**，**工具**，**思想**。

#### 操作系统

- linux基本操作。
- linux基本监控指标。
- linux进程知识。
- linux网络知识。

#### 工具

工具大概又要分成几类：

- 数据库：mysql，elasticsearch等。
- 缓存：redis，memcache等。
- 队列：kafka等。
- 容器：docker，k8s等（k8s不是docker的平行选型）。
- 协议：http，tcp，udp（协议以软件为载体，暂且也成为工具）。

#### 思想

- 编码思想：mvc，中间件，依赖注入，并发模型，编程范式等。
- 分布式与大数据下的编码。
- c10k问题：与时俱进。
- 微服务与容器化。
- 密码及安全。

### 最后说两句

很多时候学的再多不实践也没用，道理都懂依然会踩坑，祝好。


