> 最近处理的一些业务让我联想到了一些与“lazy”相关的场景，这让我对lazy这件事体会更深。

### 初识lazy

我是个前端，当然，在我几年前准备校招的时候就牢记了lazy load这个几乎是必考题的知识点，这个知识点可以衍生出很多相关问题（甚至也可以聊一下午），这里不再多说。可以在一个图片丰富的页面中使用lazy load，达到优化首屏的效果。

在前端的优化中，对于网页中一些绕不开的要素的优化，关键是让runtime去做更少的事，可以从两个方面考虑：

- 把事情提前做
- 把事情延后做（lazy）

这是个说lazy的随笔哈，那么除了对Image的lazy load，还有譬如动态import，也是一个典型的lazy优化。可以使用lazy优化的要素往往是不影响首屏但是对于整站来讲是必须的。lazy有时候不像是一种优化方式，更多的像是编程范式，在性能达到瓶颈之前，不妨优先的考虑它。

### graphQL与lazy

在实际的服务端编码中，我们的一个字段可能会衍生一大堆数据，这其中又有一系列的io和cpu计算，当类似的需求增多时，每一行衍生的信息开始变得庞大，出现了几个问题：

- 前端越来越臃肿
- 服务越来越慢
- io变多，服务出错率变高

针对越来越臃肿的前端，用户看不下去了，商讨决定将一部分非必要信息收起来，总而言之，这块的数据可以分离了，前端非常愉快的处理了这个需求，然而服务端沉思了，这个改造起来或许没那么简单。可能对于某些设计的比较好的程序来讲，这也不算困难，但相对于零成本的GraphQL来讲还是难一些。这样一来，老实说，GraphQL对后端也有好处呀！

### golang new与make

golang中使用[new初始化](https://golang.org/doc/effective_go.html#allocation_new)结构体的时候memory的申请是lazy的，如果不使用它，那么它的内存占用就是0，这lazy的很自然。不但节省了初始化的内存分配量，这部分分配内存的时间也省了，把这部分时间分摊到各个结构体实际使用的时刻，并且只影响第一次使用，所以感觉上这个lazy很值。相比make则是实际申请内存了，各有所爱，看自己想法了（这个问题社区也有很多讨论）。

实际上引出的一个话题叫[lazy initialization](https://en.wikipedia.org/wiki/Lazy_initialization#JavaScript)，不局限与golang，用自己熟悉的语言熟悉的语法，这个一般都比较容易实现。


### 数据失去同步了

***不可靠的操作***

在实际业务中我们很难达到一个完美的境界，现实总是坑坑洼洼的。最近接手了一个项目，项目里有类似这样一段代码：

```js
await A()
await B()
await C() 
```

其中A通过rpc写业务方的数据，C是在系统测同步，那么因为B偶尔会出错throw出去，这时候执行了A但是没有执行C，导致我们累计了一些状态不同步的问题。嗨！我当是啥问题呢？写个脚本不就完了？这简直是大错特错了，脚本不具有实时性，影响依然会时不时的冒出来。正确的做法是在读的过程中，以业务方的数据为准，做一次对齐，这样的同步虽然看起来不是实时的，但是对于用户来讲是实时的，这就足够了。

这跟lazy有啥关系？当然，数据不同步确实是问题，但是确实不是需要实时解决的，也没办法实时解决，lazy到一个真正需要同步的时刻去解决，是最好的。

***别急着修正数据***

两个表A,B，其中A的b字段与B的id关联，结构是数组。一个场景是当B中的某个条目被删除，要怎么处理A中的数据？急着同步A的每一行？这不太好，因为当A的规模太大时，负担会很大。在某些场景下，即使A中的b字段存在无效id这也是没问题的，联表查询会自动干掉无效id，等在次编辑A的b字段时会真正的修正这个字段。

> 这真是有趣
