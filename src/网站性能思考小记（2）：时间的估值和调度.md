---
date: 2022-04-13
tags: 思考
---

从源码 => 到用户可运行的代码 => 到用户加载 => 最后到用户浏览

### 最贵的时间

想想那些时间最贵？**用户加载时间越长，产品就越容易失去用户，我认为一定是加载时间**。前端常常在首屏上用尽功力，为了让这个时间变短，要尽可能：

1. 做更少的事
    - 能提端前做的事提前做：服务端渲染，资源预请求，dns预解析，server push
    - 能延后做的事延后做：dynamic import，lazy load，script的async属性
    - ...
2. 更快的做事
    - 缓存：
    - 并行：split chunk，web worker
    - 更优的算法：http2，gzip
    - “外包”：worker，gpu线程
    - ...

> 想象一下，优化的过程就是在优化一个排期甘特图（一种任务分配调度的可视化），拆解任务，按优先级排序，抓核心，合理调度团队成员能力，更快速的完成p0核心任务。技术&管理也是互通的

### 最便宜的时间

在近十年nodejs的发展中，优秀工具遍地开花，这也给前端提供了“compile”的能力，这部分***compile时间其实是很便宜的***，如果能利用着部分时间，在我看来几乎稳赚不赔，当然，打包也不能有明显瓶颈，但如果增加一个十几秒的任务能获得不错的优化，上线也不会差这十几秒吧？举例：

- uglify
- gzip预计算
- split chunk
- inline image
- tree shaking
- ...

### 珍惜每一帧，打造流程体验

对于单个tab，主线程不但处理js还处理渲染，如果想让体验流畅，需珍惜每一帧：

1. 大任务拆解：

- react：react17+实现了fiber数据结构，摆脱了递归stack的局限性

2. 获取帧头：

- requestAnimationFrame：下一帧开始时回调，在此执行任务能最大程度与帧同步，避免卡顿
- 应用：https://github.com/wilsonpage/fastdom

> 假设一个task 8ms，一帧16ms，如果不在帧头执行，卡帧的概率是？

3. 把握渲染：

- 改了css，要知道会发生了什么，像是重排这样的计算量很大的操作，会引起卡帧，要尽可能避免
- 能否有方法让gpu线程帮主线程分担压力？