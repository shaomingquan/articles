---
date: 2021-02-04
tags: 思考
---

> 最近在做crm系统，对于表单，列表动态性要求很高，简单来讲就是UI要求完全可配置，加一个字段，减一个字段都可以支撑。从去年11月开始技术调用，到目前已经开发两个，目前这套东西大体成型，记录一下思路。

### 整体历程

1. 表单列表低代码
2. 表单列表插件化
3. 字段元信息转化
4. 权限控制

### 低代码 & 插件化

动态化其实也就是配置驱动，它需要一种媒介，要求：

- 易组装
- 可序列化

如何组装一段代码？可能需要宏，或者代码生成。如何组装一段json？它可能通过网络传给前端，然后又可以通过前端进行重组。显然json更满足动态化媒介的需求，而业界也有一些使用json直接产生组件的实践，这套东西对应的概念也就是”低代码“。

因为”低代码“的代码只是json，接受了低代码其实一定程度上接受了场景上的受限，比如我这里只对列表和表单做低代码。但是就场景内部的子问题，需要一定的灵活度和可拓展度，需要一套标准，依照此执行可以快速的支持新的子场景。

- 场景，表单
    - 子场景，表单组件：文本框，数字框，下拉框，等等
- 场景，列表
    - 子场景，单元格展示：文本展示，日期展示，链接展示，等等

直白来讲，如果产品需要一种新的字段形式，如何实现这个组件，能让该组件直接融入这套体系，这就是所谓的“插件化”。

> 插件(Plug-in,又称addin、add-in、addon或add-on,又译外挂)是一种遵循一定规范的应用程序接口编写出来的程序。

以表单中的表单组件为例，无论是antd的实现，还是其他各种各种组件库，还是复杂的富文本组件，它们都有一些共同的要素：

- 值输入
- 值输出的回调
- 交互事件（blur，input，focus，clickOutSide）
- 状态渲染（loading，disabled，invisible）
- ...

其实东西挺少的，只需做一层封装，很容易实现一个插件。那么一个表单呢？**就是对一组插件描述的封装和排布**，这里发挥的空间就更多了：

- 布局动态化
- 各种插槽
- 回调收敛
- 自动表单验证
- ...

这里说一下回调收敛，对于一个业务表单，我希望业务时内聚的，单个组件影响一个字段，整个表单要通过单个回调get到每个字段的变化，从而对外部的数据做更改。对于表单来讲，`onChange`的签名是这样`(key: string, value: any) => void`，单个组件的`onChange`的签名是这样`(value: any) => void`。在表单封装层做了个转化：

```js
const formOnChange = props.onChange
const widgetKey = 'customer_name'
const widgetOnChange = (value) => {
    formOnChange(widgetKey, value)
}
<Widget
    onChange={widgetOnChange}
/>
```

最终把表单组件的值变化收敛到表单封装层。

### 元信息转化 & 权限控制

元信息不但会服务前端，也会服务于后端，它不是一个ui性质的配置。在bff，前端把元信息转成表单和列表对应的json，这里没啥技术上的事情，就是json转json。因为插件有状态展示支持，通过权限接口作用于元信息转化过程，可以轻易的控制表单组件的visible，disable。

### container接口化 & store可组装且高透传

题外话，为了支持高封装，高灵活的一种方案。

而container本来是作为依赖被业务使用，这里反向思考，container只实现，并且对业务提出需求，当业务需要使用container的时候，业务store只要实现某些接口即可，ts对于这种事十分擅长。比如，对于一个上文中的插件化的动态列表，需要实现：

- 分页相关成员
- 排序相关成员
- ...

所以从业务store到container，只需要透传一个业务store即可，封装度很高，并且在外部持有业务store，对其中的数据完全掌控，灵活度极好。随后很容易发现，一些功能是比较内聚的，比如分页这几个成员总是会同时出现，类似的有很多，这些都可以封装成**功能store**store。按此维度将store分为：

- 功能store
- 业务store

业务store通过组合继承，按需将功能store加入到自己的成员中，就是所谓的可组装。