---
date: 2022-03-27
tags: 思考
---

### 不符合产品设计预期的使用方式，case未覆盖全

- 交互用例给的不全，同时研发也疏忽
- 未完全按产品设计实现，留有隐僻的后门
- 不注重非功能性需求

有个项目中有个搜索功能，通过右上角输入框，可以在新窗口显示搜索内容。产品偶尔会收到用户bug反馈，搜索出的内容缺失对应的操作（比如收藏功能）。最开始前端团队的判断是无法复现，并怀疑个后端的权限接口偶尔不稳定。

后面频繁反馈这个bug，经过code review发现，当用户不搜索任何内容的时候，也可以打开新页面，但这种场景下没有请求权限，所以自然没有操作按钮。

所以从产品到研发到测试都没有注意到输入内容为空这个case，在得到用户反馈时，只按照自己既定的剧本复现，给出偶现的结论。

> 偶现真的是偶现吗？有时候是用户不愿意说，处在一种凑合用的心态，产研团队能给用户建立一个良好的反馈通道很重要，同时也要更主动贴近用户，特别是对于问题要刨根问底

再谈谈非功能性需求，一般是错估用户的使用方式，有两个case：

- 一个秒杀的场景，用户通过多开窗口让qps至少达到了10倍以上，导致预估不足，发生大批量的超时
- 一个呼叫中心的场景，第三方sdk对于多窗口互踢支持的并不好，然而在测试中却有点疏忽这件事，导致在打开多窗口时，有时无法重新登录

> 这里就不再分享解决方案了，秒杀的方案很成熟，呼叫中心嘛比较冷门。想说的就是，非功能性方案一定要注意，并且作为研发，更应关注非功能性需求

### 不符合immutable的规范，且时序问题让其不会稳定暴露

`y = f(x)`，众所周知，react组件应该是一个纯函数，对于一组state，如果存在不可预知的副作用，使`f(x)`前后的值不同，就潜在的埋了一次雷。为什么说是埋雷？因为有些时候这些问题不能立马出现，有时候拿到新state的时候，未经历二次update，则永远不会暴露。一些情况下，我们需要通过多个异步操作拿多份state，实际上render应用这些state的时序是不稳定的，对于单个state而言，有时候是单次update，有时候是多次update，引发不稳定复现的bug。

> immutable原则，不要通过改变引用本身去衍生状态，要保证重复衍生稳定（纯），用immer（或者好歹用个deepClone）
