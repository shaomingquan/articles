---
date: 2019-10-12
tags: 思考
---

### 设计的臭味

> 下面思考部分来自smq，“设计的臭味”来自《敏捷软件开发》这本书

- 1. 僵化性
- 2. 脆弱性
- 3. 牢固性
- 4. 粘滞性
- 5. 不必要的复杂性
- 6. 不必要的重复
- 7. 晦涩性

**思考**

- 僵化性是指改一个看起来很小的点，实际上要改很多其他地方，导致对功能开发时长预估不准。出现僵化，会让我们对于开发成本估算不准，影响交付或者产生加班。
- 脆弱性是指改一个点，影响了看起来毫不相干的点。这要求我们解耦，并且能通过工具获取当前模块的被ref情况。抛开设计角度，如果团队成员能掌握当前模块被其他模块的依赖情况，事情会好很多。并且越僵化其实就越脆弱。
- 牢固性指功能分享困难，拆不出来。这要求我们尽可能不搞大组件或函数，要拆的细一些，以及要有npm registry，以及使用monorepo。
- 粘滞性指保持好设计，好规范的成本太高，导致好的东西慢慢被放弃（劣币驱逐良币）。一方面依赖管理，比如不给code review和做上线规划排期，那么慢慢的这些事情就会被遗忘，或者效果大打折扣。一方面需要完善的工具链，让好设计好规范可以延续，自动格式化，检查git命令并拦截，上线工具。
- 不必要的复杂性。就是字面意思，提前抽象，以及用一些不必要的选型
- 不必要的重复。该抽象就抽象（重复3次以及以上
- 晦涩性。易读。

### 消除臭味的方案

> 下面思考部分来自smq，“消除臭味的方案”来自《敏捷软件开发》这本书

- 1. 单一职责原则
- 2. 开放封闭原则
- 3. liskov替换原则
- 4. 依赖倒置
- 5. 接口隔离原则

**思考**

- 1. 单一职责原则：指单个模块有且只有一个引起它变化的原因。如果两个总是一起变化的因子就可以不用拆开，这时候拆开反而增加不必要的重复性，否则应该拆开，这时不拆开让程序增加僵化性和脆弱性，书上说的是，会导致部署和编译成本增加。如果A，B功能在一起，A频繁改变，会导致B频繁编译，这些编译是不必要的。其实也导致依赖不清晰，通过阅读代码发现实际依赖变得困难。
- 2. 开放封闭原则：对于拓展是开放的，对于改变是封闭的，给模块拓展一个功能，如果能不改变模块源代码就不改变，且这个拓展越容易越佳，低侵略，易插拔。举了一个client server的例子，和shape的例子，简单来说就是调用方定接口，实现方按接口实现，这种思想不仅仅局限于软件内部，软件之间也可以。再一种就是hook，其实就是回调了，或者是一些方法的重新实现，像是一些面向过程的抽象，比如React的生命周期。React的hook方法也比较符合开放封闭原则，侵略性不算大，插拔也还算不难。
- 3. liskov替换原则：子类必须能替换掉它们的基类，它是一个如何实现开放封闭原则的原则。如果D是B的派生类，那么对于测试case F，如果F(B)通过，F(D)也应该通过，万万不可因F(D)不通过再新加测试case使其通过，而放弃F(D)的测试过程。**IS-A是行为上的**，书中拒了Square和Rectangle的例子非常好，看起来Square is a Rectangle实际上，Square不满足Rectangle的一些行为，在编写单元测试时，要基于契约去设计。
- 4. 依赖倒置：高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应依赖细节，细节应该依赖抽象。倒置我理解体现在，高层模块从依赖底层模块的实现，到底层模块依赖于一个约定好的接口，以提高高层模块的复用性。其实有点类似向前兼容，不管是语言内部还是说rpc吧，dip总是合适的。实际上dip传达的价值观是，我们定的interface要让高层（业务）舒服。插件模式也是依赖倒置的很好的例子，插件本身作为底层依赖要想加入到高层体系中，需要实现高层指定的interface。而ts中的鸭子类型，让依赖倒置变得更容易。
- 5. 接口隔离原则。解释这个不如直接了解接口污染，相当于是接着依赖倒置来说的，高层interface妥协于某个底层实现，从而使interface冗余，产生的interface污染，这种不断膨胀的interface书中叫做fat class（胖类）。如果上层使用的方法差别很大，则不应该复用interface，应该拆分（隔离）。如果语言支持多继承，则使用多继承解决，像是在js中，是无法支持多继承的（原型链的局限，或许有封装但总归不优雅），我这边用了组合的方式，把其他模块的功能拆分并融合